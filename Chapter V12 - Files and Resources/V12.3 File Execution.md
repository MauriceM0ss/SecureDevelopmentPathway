# V12.3 File Execution

## 12.3.1 Verify that user-submitted filename metadata is not used directly by system or framework filesystems and that a URL API is used to protect against path traversal

Op het moment dat de metadata van bestandsnamen wordt overgenomen kunnen er meerdere risico's optreden. Aan de ene kant kunnen er bestanden met dezelfde naam elkaar overschrijven, waardoor oude bestanden verloren gaan, of kan er path traversal optreden, waar een aanvaller via bijvoorbeeld de bestandsnaam posities terug kan gaan in de folder structuur en mogelijk systeem bestanden kan overschrijven.

### Hoe te testen?

#### Optie 1 (manueel)

1. Upload een bestand en onderschept het verzoek met een tool zoals Burp Suite of Owasp ZAP.
2. Verander de naam van het bestand naar bijvoorbeeld:

    ```bash
    ../../folder/file_on_system.txt ## Vervang met bestand op server.
    ```

3. Onderzoek of het bestand in de subfolder wordt geplaatst.

Voor meer informatie zie [PortSwigger - Path Traversal](https://portswigger.net/web-security/file-path-traversal)

#### Optie 1 (via SAST)

Maak gebruik van SAST tooling voor het detecteren van mogelijke Path Traversal code smells.

### Hoe te implementeren?

1. Maak gebruik van de upload functionaliteit zoals deze beschikbaar is binnen standaard frameworks. Voorkom het zelf bouwen van bestandsupload-functionaliteiten om onnodige kwetsbaarheden te beperken.
2. Bij het uploaden van bestanden vervang de naam met een random string zoals e.g. UUID4.
3. Indien dit niet past in de use case, zorg dat de inputnaam wordt veranderd in betrouwbare tekens, zie [Input Validation Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html#upload-storage)

Voor meer informatie zie: [File Upload Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/File_Upload_Cheat_Sheet.html#filename-sanitization)

## 12.3.2 Verify that user-submitted filename metadata is validated or ignored to prevent the disclosure, creation, updating or removal of local files (LFI)

Op het moment dat de metadata van bestandsnamen wordt overgenomen kan Local File Inclusion (LFI) optreden, hierbij wordt er een lokaal bestand terug gegeven waardoor mogelijk gevoelige data uitlekt.

### Hoe te testen?

#### Optie 1 (manueel)

Test voor LFI door het bestandsnaam te veranderen naar e.g.:

##### Linux

```bash
./../../etc/passwd ## Of ander bestand op Linux server
```

##### Windows

```bash
C:/installerLog.txt ## Of ander bestand op Windows server
```

Voor meer informatie zie, [PortSwigger - File Upload](https://portswigger.net/web-security/file-upload)

#### Optie 2 (via Pentest)

Vraag een Pentest aan.

#### Optie 3 (via SAST)

Maak gebruik van SAST tooling voor het detecteren van mogelijke path injection code smells.

#### Optie 4 (via fuzzing tool)

Maak gebruik van automatische fuzzing tooling, e.g. <https://github.com/hansmach1ne/LFImap>.

### Hoe te implementeren?

Volg de best practices genoemd in <https://cheatsheetseries.owasp.org/cheatsheets/File_Upload_Cheat_Sheet.html>

## 12.3.3 Verify that user-submitted filename metadata is validated or ignored to prevent the disclosure or execution of remote files via Remote File Inclusion (RFI) or Server-side Request Forgery (SSRF) attacks

Omdat de input van bestandsnamen mogelijk verwerkt wordt door de server of servers die draaien op de interne systemen is het belangrijk dat voordat deze in de informatieflow worden verstuurd eerst geverifieerd worden, dit om te voorkomen dat externe bestanden worden ingeladen.

### Hoe te testen?

#### Optie 1 (Pentest)

Vraag een Pentest aan.

#### Optie 2 (manueel)

Test voor RFI door als bestandsnaam een website op te geven, e.g.: <http://example.com/robots.txt>

### Hoe te implementeren?

Volg de best practices genoemd in <https://cheatsheetseries.owasp.org/cheatsheets/File_Upload_Cheat_Sheet.html>

## 12.3.4 Verify that the application protects against Reflective File Download (RFD) by validating or ignoring user-submitted filenames in a JSON, JSONP, or URL parameter, the response Content-Type header should be set to text/plain, and the Content-Disposition header should have a fixed filename

Bij een Reflective File Download is een aanvaller in staat om een download vanuit een vertrouwde bron te laten komen zonder dat deze download daadwerkelijk of de server staat. Een wat uitgebreidere uitleg is te vinden op <https://github.com/daffainfo/AllAboutBugBounty/blob/master/Reflected%20File%20Download.md>.

### Hoe te testen?

#### Optie 1 (manueel)

1. Zoek gereflecteerde invoer (bijvoorbeeld: JSONP Callback).
2. Controleer dat de `filename` niet wordt opgegeven bij de `Content-Disposition`.

#### Optie 2 (via Pentest)

Vraag een Pentest aan.

### Hoe te implementeren?

Maak gebruik van de `filename` attribuut van `Content-Disposition`, e.g.

```text
Content-Type: text/plain
Content-Disposition: attachment; filename="report.json"
```

## 12.3.5 Verify that untrusted file metadata is not used directly with system API or libraries, to protect against OS command injection

Omdat bestanden die worden ge√ºpload door gebruikers gemanipuleerd kunnen worden is het belangrijk dat deze input niet wordt verwerkt door de server. Indien dit wel het geval is, kan het voorkomen dat via de metadata commando's worden uitgevoerd door de server bij het verwerken van de input.

### Hoe te testen?

#### Optie 1 (via Pentest)

Vraag een Pentest aan.

#### Optie 2 (manueel)

Het volgende artikel legt een mogelijke aanval uit: <https://medium.com/@Cyber_siva/command-injection-by-uploading-image-ef72e168980c>

#### Optie 3 (via SAST)

Maak gebruik van SAST tooling voor het detecteren van code smells die OS command injection mogelijk maken.

### Hoe te implementeren?

1. Zorg dat metadata van onbetrouwbare bestanden nooit wordt ingeladen door de server.
2. Indien dit niet anders kan, zorg dat metadata sanitized wordt alvorens deze te gebruiken.
