# V5.2 Sanitization and Sandboxing

## 5.2.1 Verify that all untrusted HTML input from WYSIWYG editors or similar is properly sanitized with an HTML sanitizer library or framework feature

WYSIWYG is een afkorting voor What You See Is What You Get. Een voorbeeld hiervan is de Confluence Editor waar je meteen te zien krijgt hoe de input zichtbaar gaat worden op het moment dat er publish of update wordt gedrukt. Indien input niet correct verwerkt wordt is het via deze editors mogelijk om bijvoorbeeld javascript te injecteren in de pagina.

### Hoe te testen?

#### Optie 1 (via Pentest)

1. Vraag een Pentest aan.

#### Optie 2 (via SAST)

Integreer SAST in je pipeline en analyseer de code smells over sanitized input.

### Hoe te implementeren?

* In de meeste gevallen is het gebruik van de nieuwste versie van een gestandaardiseerde framework afdoende.
* Indien er voor een Sanitizer wordt gekozen, is een mogelijke optie <https://github.com/cure53/DOMPurify>

## 5.2.2 Verify that unstructured data is sanitized to enforce safety measures such as allowed characters and length

Voordat data downstream wordt verstuurd is het belangrijk dat deze wordt gezuiverd om er zeker van te zijn dat deze geen karakters of data van een lengte stuurt die verkeerd geïnterpreteerd kunnen worden door de systemen verder in de applicatie-flow.

### Hoe te testen?

#### Optie 1 (via Pentest)

Vraag een Pentest aan.

#### Optie 2 (via SAST)

Integreer SAST in je pipeline en analyseer de code smells over sanitized data.

### Hoe te implementeren?

1. Indexeer hoe de verwachte data input eruit ziet op de server.
2. Zorg dat data is gesanitized voordat deze wordt doorgestuurd.

## 5.2.3 Verify that the application sanitizes user input before passing to mail systems to protect against SMTP or IMAP injection

In sommige gevallen communiceert een systeem met een SMPT of IMAP server voor het versturen van bijvoorbeeld emails gebaseerd op de input. Door gebruikers input te sanitizen alvorens deze te versturen verklein je de kans op SMTP of IMAP injectieaanvallen, waarbij een aanvaller kwaadaardige commando’s kan injecteren die door het e-mailsysteem worden uitgevoerd, wat kan leiden tot ongeautoriseerde toegang tot e-mailberichten of zelfs het hele e-mailsysteem.

### Hoe te testen?

#### Optie 1 (via Pentest)

1. Vraag een Pentest aan.

#### Optie 2 (manueel)

In het geval dat er de behoefte is om  dit zelf te testen is er op de volgende pagina's meer informatie te vinden:

* <https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/07-Input_Validation_Testing/10-Testing_for_IMAP_SMTP_Injection>
* <https://book.hacktricks.xyz/pentesting-web/ldap-injection>

#### Optie 3 (via SAST)

Maak gebruik van een SAST tooling voor het detecteren van code blocks die mogelijk tot SMTP of IMAP injectie kunnen leiden.

### Hoe te implementeren?

* Indien er wordt gecommuniceerd met een SMTP of IMAP server is het aanbevolen om geen eigen implementatie te bouwen maar gebruik te maken van bestaande en moderne frameworks en libraries.
* Zorg dat data sanitized wordt alvorens het verstuurd wordt met bijvoorbeeld een tool zoals  <https://github.com/cure53/DOMPurify>

## 5.2.4 Verify that the application avoids the use of eval() or other dynamic code execution features. Where there is no alternative, any user input being included must be sanitized or sandboxed before being executed

Het gebruik van eval wordt gezien als onveilig omdat deze code arbitrair uitvoert. Dit is ook de reden dat bijvoorbeeld in de CSP header expliciet aangegeven moet worden dat eval toegestaan is door middel van de waarde 'unsafe-eval'. Om deze reden is het gebruik van eval dan ook niet toegestaan.

### Hoe te testen?

#### Optie 1 (manueel)

1. Kijk of eval voorkomt in de source code.

#### Optie 2 (via SAST)

1. Maak gebruik van een SAST tooling voor automatische checks naar code blocks met de eval functie.

### Hoe te implementeren?

1. Doorzoek de code op de waarde eval.
2. Vervang de logica waar dit wordt gebruikt.

## 5.2.5 Verify that the application protects against template injection attacks by ensuring that any user input being included is sanitized or sandboxed

Template injection attacks laten het toe om commando's vanuit de server uit te voeren. Een voorbeeld die vaak gebruikt wordt om te testen is om de som 7*7  te sturen en te kijken of 49 wordt terug gestuurd. Indien dit het geval is impliceert dit dat de input op de server wordt uitgevoerd. Vervolgens is het voor een aanvaller mogelijk om ook commando's uit te voeren.

### Hoe te testen?

#### Optie 1 (manueel)

1. Gebruik de volgende polygot om te controleren of er een foutmelding wordt getoond, indien dit het geval is wijst dit op Template Injection:

 ```text
 ${{<%[%'"}}%\.
 ```

#### Optie 2 (via SAST)

Maak gebruik van een SAST tooling voor automatische checks voor template injection.

### Hoe te implementeren?

* In de meeste gevallen is het gebruik van de nieuwste versie van een gestandaardiseerde framework afdoende.
* Indien er voor een Sanitizer wordt gekozen, is een mogelijke optie <https://github.com/cure53/DOMPurify>.

## 5.2.6 Verify that the application protects against SSRF attacks, by validating or sanitizing untrusted data or HTTP file metadata, such as filenames and URL input fields, and uses allow lists of protocols, domains, paths and ports

In veel gevallen zijn systemen zoals databases niet vanaf buitenaf beschikbaar. Via enable listen (allow lists, white lists) wordt bijvoorbeeld alleen toegang gegeven tot de webserver om een database query uit te voeren. In het geval van Server Side Request Forgery (SSRF) aanvallen is dit te omzeilen waardoor het mogelijk is om interne servers aan te roepen, dit kan onder andere leiden tot het lekken van gegevens en toegang tot interne systemen.

### Hoe te testen?

#### Optie 1 (via Pentest)

Vraag een Pentest aan.

#### Optie 2 (manueel)

Controleer zelf op:

* **Validatie van invoer**: Controleer of alle invoervelden die URL’s accepteren, correct worden gevalideerd.
* **Sanitization van invoer**: Word Sanitization toegepast op onbetrouwbare gegevens (zoals bestandsnamen en URL’s)?
* **Allow-listing van protocollen, domeinen, paden en poorten**: Wordt er een allow list gebruikt om te beperken welke externe bronnen kunnen worden aangevraagd? Zorg ervoor dat alleen toegestane protocollen (bijv. HTTP, HTTPS) en domeinen worden geaccepteerd.

#### Optie 3 (via SAST of DAST)

Maak gebruik van SAST en/of DAST tooling om te controleren op mogelijke SSRF aanvallen.

### Hoe te implementeren?

Bestudeer en implementeer de mitigatie genoemd in: <https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html>

## 5.2.7 Verify that the application sanitizes, disables, or sandboxes user-supplied Scalable Vector Graphics (SVG) scriptable content, especially as they relate to XSS resulting from inline scripts, and foreignObject

Voor het tonen van afbeeldingen zijn er veel verschillende formaten, 1 van die formaten is Scalable Vector Graphics (SVG), dit zijn afbeeldingen die zoals bijvoorbeeld Adobe Ilustrator geen maximale grootte hebben maar gedefinieerd worden door code. Dit betekend dat indien dit format wordt toegestaan een aanvaller mogelijk ook scripts kan toevoegen die kunnen leiden tot het injecteren van bijvoorbeeld javascript code.

### Hoe te testen?

#### Optie 1 (via Pentest)

Vraag een Pentest aan.

#### Optie 2 (via SAST of DAST)

Maak gebruik van SAST en DAST tooling om te controleren op mogelijke XSS aanvallen via SVG in de applicatie zitten.

### Hoe te implementeren?

1. De makkelijkste manier is om geen SVG toe te staan maar gebruik te maken van bijvoorbeeld PNG.
2. Indien dit geen keuze is,

* Maak een allow list met alleen veilige SVG elementen, hierdoor wordt een ```<script>``` bijvoorbeeld geblokkeerd.
* Zorg dat je input sanitized alvorens deze te gebruiken in de rest van de code flow.

## 5.2.8 Verify that the application sanitizes, disables, or sandboxes user-supplied scriptable or expression template language content, such as Markdown, CSS or XSL stylesheets, BBCode, or similar

Indien scriptable expressions worden verwerkt door een website kan dit verschillende gevolgen hebben. In de meeste gevallen zal het kunnen leiden tot injectie van code via bijvoorbeeld CSS (e.g. XSS). Omdat input wordt verwerkt zullen de instructies die een gebruiker meegeeft ook worden uitgevoerd, hierbij zijn er verschillende "trucs" voor een aanvaller om hierbij informatie naar een externe bron of acties vanuit de browser te laten uitvoeren. Een voorbeeld hiervan is een keylogger via CSS: <https://midhlaj.medium.com/css-as-a-keylogger-81c6fcd1a3c2>.

### Hoe te testen?

#### Optie 1 (Pentest)

Vraag een Pentest aan.

#### Optie 2 (manueel)

Voer de volgende payload in bij een invoerveld en zie of deze klikbaar is:

* [markdownxss click here](javascript:this;alert(1))
* Voor meer voorbeelden en uitleg zie het volgende [Medium artikel](https://lopseg.medium.com/markdown-xss-tips-e166905b1f5e).

#### Optie 3 (SAST of DAST)

Maak gebruik van SAST en DAST tooling om te controleren op mogelijke injectie in input.

### Hoe te implementeren?

* Maak gebruik van bestaande frameworks en zorg dat er een update beleid is om op de nieuwste versie te blijven.
* Vermijd het verwerken van expression language content tenzij dit essentieel is voor de verwachte use case.
