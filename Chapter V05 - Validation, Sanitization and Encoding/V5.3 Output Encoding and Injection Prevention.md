# V5.3 Output Encoding and Injection Prevention

## 5.3.1 Verify that output encoding is relevant for the interpreter and context required. For example, use encoders specifically for HTML values, HTML attributes, JavaScript, URL parameters, HTTP headers, SMTP, and others as the context requires, especially from untrusted inputs (e.g. names with Unicode or apostrophes, such as ねこ or O'Hara)

Vaak worden er generieke encoders gebruikt voor alle functionaliteit binnen een applicatie. Toch is er veel te winnen door te kijken naar de use case van de encoder. Zo heeft een naam input veld in de meeste gevallen een ruimere encoder nodig dan HTML encoders. Door output encoding op een context manier te configureren heb je een betere bescherming tegen injectie aanvallen zoals XSS.

### Hoe te testen?

#### Optie 1 (via code)

Loop je code na en controleer waar output encoding plaatsvindt. Controleer of de gekozen encoding in de context de juiste is.

### Hoe te implementeren?

Volg de [OWASP Developer Guide](https://owasp.org/www-project-developer-guide/draft/design/web_app_checklist/encode_escape_data/) over dit onderwerp.

## 5.3.2 Verify that output encoding preserves the user's chosen character set and locale, such that any Unicode character point is valid and safely handled

Vanuit een security perspectief is het belangrijk om zekerheid te hebben in hoe data wordt verwerkt. Helaas is dit bij encoding soms lastig. Doordat er een andere standaard wordt gebruikt kan een ね opeens worden omgezet naar een < omdat deze anders is gedefinieerd in de karakter set. Om deze reden is het belangrijk dat de karakter set en landinstellingen van een gebruik worden gevolgd of dat systemen data van verschillende karakters sets veilig verwerkt.

### Hoe te testen?

#### Optie 1 (manueel)

Je kunt dit handmatig testen door verschillende Unicode-tekens in te voeren in de velden van de applicatie en te controleren of ze correct worden weergegeven in de output zonder enige vervorming of onverwacht gedrag. Voorbeelden kunnen gevonden worden op: <https://www.cogsci.ed.ac.uk/~richard/unicode-sample.html>

### Hoe te implementeren?

Maak gebruik van de functionaliteit van industry standard frameworks om dit correct af te vangen.

Voor meer informatie zie: [OWASP Developer Guide | Encode and Escape Data Checklist | OWASP Foundation](https://owasp.org/www-project-developer-guide/draft/design/web_app_checklist/encode_escape_data/)

## 5.3.3 Verify that context-aware, preferably automated - or at worst, manual - output escaping protects against reflected, stored, and DOM based XSS

Output escaping is onderdeel een essentieel tegen de bescherming van XSS. Door in plaats van een < mee te sturen deze te escapen naar ```&lt;``` wordt dit correct op een pagina getoond maar kan er geen code worden geïnjecteerd omdat de server en browser begrijpt dat het om gebruikers input gaat.

### Hoe te testen?

#### Optie 1 (via Pentest)

Vraag een Pentest aan

#### Optie 2 (via polyglot)

Indien handmatig getest moet worden kan de volgende polyglot worden gebruikt:

```javascript
jaVasCript:/*-/*`/*\`/*'/*"/**/(/* */oNcliCk=alert() )//%0D%0A%0d%0a//</stYle/</titLe/</teXtarEa/</scRipt/--!>\x3csVg/<sVg/oNloAd=alert()//>\x3e
```

#### Optie 3 (via SAST)

Maak gebruik van SAST tooling om te detecteren als er ergens output encoding ontbreekt die kan leiden tot XSS.

### Hoe te implementeren?

Volg de [OWASP Cheat Sheet series](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html) over dit onderwerp.

## 5.3.4 Verify that data selection or database queries (e.g. SQL, HQL, ORM, NoSQL) use parameterized queries, ORMs, entity frameworks, or are otherwise protected from database injection attacks

Om SQL injection of gelijkwaardige injectie aanvallen te voorkomen is het belangrijk dat input data van een gebruiker separaat van de technische logica wordt verstuurd, e.g. SELECT * from news WHERE id = ?. Vervolgens wordt apart ? = 123 gestuurd. Behalve dat hierdoor SQL injectie niet meer mogelijk is, versnelt dit ook de operaties van je database.

### Hoe te testen?

#### Optie 1 (via Pentest)

Vraag een Pentest aan.

#### Optie 2 (via polyglot)

Indien er handmatig getest moet worden, kan de volgende polyglot worden gebruikt als input:

```sql
SLEEP(1) /*’ or SLEEP(1) or’” or SLEEP(1) or “*/
```

#### Optie 3 (via SAST)

Maak gebruik van SAST tooling om te detecteren van SQL injection mogelijkheden.

### Hoe te implementeren?

Volg de [OWASP Cheat Sheet series](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html) op dit onderwerp.

## 5.3.5 Verify that where parameterized or safer mechanisms are not present, context-specific output encoding is used to protect against injection attacks, such as the use of SQL escaping to protect against SQL injection

> [!CAUTION]
> Het advies is om de requirement niet te implementeren. Mogelijk introduceert deze namelijk performance en security risico's. Verder is deze verwijderd in ASVS 5.0.

## 5.3.6 Verify that the application protects against JSON injection attacks, JSON eval attacks, and JavaScript expression evaluation

Het is belangrijk dat op het moment dat JSON wordt verwerkt deze niet door een aanvaller gemanipuleerd kan worden. Dit kan er namelijk toe leiden dat JSON wordt geïnjecteerd om code te uit voeren die malafide acties kan uitvoeren zoals bijvoorbeeld XSS.

### Hoe te testen?

#### Optie 1 (via Pentest)

Vraag een Pentest aan.

#### Optie 2 (via SAST)

Maak gebruik van SAST tooling om te detecteren van Json injection mogelijkheden.

### Hoe te implementeren?

* Maak geen gebruik van eval. Maar gebruik bijvoorbeeld JSON.parse.
* Ontwerp de applicatie op een manier dat er geen gevoelige informatie wordt laden, zoals accountinformatie en privileges, uit door de gebruiker gecontroleerde of anderszins onbetrouwbare JSON-data.
* Een andere mogelijkheid is via de Content Security Policy, die standaard het gebruik van eval voorkomt. Vervolgens dient de veiligere JSON.parse methode gebruikt te worden.

Voor meer informatie, zie: [JSON Injection (invicti.com)](https://www.invicti.com/learn/json-injection/)

## 5.3.7 Verify that the application protects against LDAP injection vulnerabilities, or that specific security controls to prevent LDAP injection have been implemented

Log4J heeft aangetoond hoe gevaarlijk LDAP injectie kan zijn. Om deze reden is het belangrijk dat de kans op LDAP injecties wordt voorkomen.

### Hoe te testen?

#### Optie 1 (via Pentest)

Vraag een Pentest aan.

#### Optie 2 (manueel)

Op <https://raw.githubusercontent.com/swisskyrepo/PayloadsAllTheThings/master/LDAP%20Injection/Intruder/LDAP_FUZZ.txt> is een lijst te vinden van prompts die gebruikt kan worden om te controleren op LDAP Injection

#### Optie 3 (via SAST)

Maak gebruik van SAST tooling voor het detecteren van mogelijke LDAP injection code smells.

### Hoe te implementeren?

Op <https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html> is het advies te vinden deze aanval te voorkomen. In het kort staat hier:

* "Escape all variables using the right LDAP encoding function"
* "Use Frameworks that Automatically Protect from LDAP Injection"

## 5.3.8 Verify that the application protects against OS command injection and that operating system calls use parameterized OS queries or use contextual command line output encoding

In sommige gevallen voeren applicaties acties uit door middel van een commando op het doelsysteem. In de meeste gevallen is het advies om dit zo veel mogelijk te vermijden maar mocht dit niet mogelijk zijn dan is het belangrijk dat dit op een veilige manier gebeurd. Indien dit namelijk niet het geval is, is het gevaar van arbitraire command injection namelijk mogelijk.

### Hoe te testen?

#### Optie 1 (via Pentest)

Vraag een Pentest aan.

#### Optie 2 (manueel)

De volgende prompt kan gebruikt worden, indien er een trage reactie tijd komt impliceert dit dat command injection mogelijk is:

```bash
& ping -c 10 127.0.0.1 &
```

#### Optie 3 (via SAST)

Maak gebruik van SAST tooling voor het detecteren van mogelijke OS command injection code smells.

### Hoe te implementeren?

Op <https://cheatsheetseries.owasp.org/cheatsheets/OS_Command_Injection_Defense_Cheat_Sheet.html> is het advies te vinden deze aanval te voorkomen. In het kort staat hier:

* "Avoid calling OS commands directly"
* "Escape values added to OS commands specific to each OS"
* "Parameterization in conjunction with Input Validation"

## 5.3.9 Verify that the application protects against Local File Inclusion (LFI) or Remote File Inclusion (RFI) attacks

Bij het uploaden en downloaden van bestanden wordt in veel gevallen de bestandsnaam meegegeven. door deze te manipuleren is het indien er geen mitigatie zijn genomen mogelijk om lokale of externe bestanden op te vragen. Dit kan leiden tot het inzien van gevoelige documentatie, zoals bijvoorbeeld een lokale configuratie bestand met informatie over de database of het inladen van externe pagina's in de context van de pagina waardoor malafide scripts op de server geladen kunnen worden wat mogelijk weer kan leiden tot de overname van de gehele server.

### Hoe te testen?

#### Optie 1 (via Pentest)

Vraag een Pentest aan.

#### Optie 2 (manueel)

1. Test voor LFI door het bestandsnaam te veranderen naar e.g.:

    **Linux**

    ```bash
    ./../../etc/passwd ## Of ander bestand op Linux server

    ```

    **Windows**

    ```bash
    C:/installerLog.txt ## Of ander bestand op Windows server

    ```

2. Test voor RFI door als bestandsnaam een website op te geven, e.g.:

    ```text
    http://example.com/robots.txt
    ```

#### Optie 3 (via SAST)

Maak gebruik SAST tooling voor het detecteren van mogelijke path injection code smells.

#### Optie 4 (via tools)

Maak gebruik van automatische fuzzing tooling, e.g. <https://github.com/hansmach1ne/LFImap>.

### Hoe te implementeren?

Volg de best practices genoemd in <https://cheatsheetseries.owasp.org/cheatsheets/File_Upload_Cheat_Sheet.html>

## 5.3.10 Verify that the application protects against XPath injection or XML injection attacks

Het gebruik van de XML format en XPath (een query language voor XML) brengt ook risico's met zich mee. Door verkeer configuratie of het niet verifiëren van de input kan dit leiden tot onder andere information disclosure maar ook authentication bypasses. Om deze reden is het belangrijk dat indien XML en zeker wanneer XPath dit secuur te configureren en afvangen. Een uitgebreide uitleg van XPath injection kan gevonden worden op: <https://learn.snyk.io/lesson/xpath-injection/>.

### Hoe te testen?

#### Optie 1 (via Pentest)

Vraag een Pentest aan.

#### Optie 2 (manueel)

Het kan complex zijn om deze aanvalsvorm juist te testen. Je ziet dat de injectie overeen komt met SQL injectie, dus de volgende string kan worden gebruikt om initieel vast te stellen of XML injectie mogelijk, mogelijk is:

```sql
' or 1=1 or ''='
```

#### Optie 3 (via SAST)

Maak gebruik SAST tooling voor het detecteren van mogelijke XML injection code smells.

### Hoe te implementeren?

Volg de best practices, genoemd in: <https://cheatsheetseries.owasp.org/cheatsheets/XML_Security_Cheat_Sheet.html>
